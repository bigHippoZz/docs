// 给定两个二叉树，编写一个函数来检验它们是否相同。

// 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

// 示例 1:

// 输入:       1         1
//           / \       / \
//          2   3     2   3

//         [1,2,3],   [1,2,3]

// 输出: true
// 示例 2:

// 输入:      1          1
//           /           \
//          2             2

//         [1,2],     [1,null,2]

// 输出: false
// 示例 3:

// 输入:       1         1
//           / \       / \
//          2   1     1   2

//         [1,2,1],   [1,1,2]

// 输出: false

// 来源：力扣（LeetCode）
// 链接：https://leetcode-cn.com/problems/same-tree
// 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

// 思路

// 这道题很重要 可以有助于理解diff算法 比较两棵树之间的区别 判断是不是一样的

/**
 *    1         1
 *   / \       / \
 *  2   1     1   2
 *  最简单来讲，比较当前两棵树，首先我们先判断当前两棵树的根节点是不是相同，相同的话进行判断左子树的值是否相同，相同的话则会判断右子树
 *  是是否相同，相同的话则进行递归
 */
// 深度搜索 DFS
function isSameTree(p, q) {
  // 当两者都为空的时候就是叶节点的时候 返回true
  if (!p && !q) {
    return true;
  }
  // 由于前面的判断已经将两者都相同的情况进行判断
  // 所以进行判断只有一个节点为空 另一个不为空的情况 则会返回false 树不会相同
  if (!p || !q) {
    return false;
  }
  // 判断当前当前节点的值是否相同 不相同则会返回false
  if (p.val !== q.val) {
    return false;
  }
  //   如果以上的情况都不存在则进行递归比较其他的节点
  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

  //   时间复杂度为 O(min(m,n)) 只有当两个棵树节点相同的情况下我们才会访问所有的节点 进行遍历的次数为 O(min(m,n))
  //   空间复杂度 为 O(min(m,n)) 注意一点 我们的空间复杂度主要是取决于递归调用调用的层级，所以递归调用的层级并不会超过树的高度
  //   而最坏的情况下则会是 树的节点数量 ，基本上应该是 O(min(Hm,Hn))
}
